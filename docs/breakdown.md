# Breakdown

Here's a comprehensive 100-point breakdown for Burgil Personal Computer, capturing all project aspects from security to functionality, future enhancements, and setup elements. Once this plan is finalized, we can develop it into a well-structured README.

1. **Project Name**: Burgil Personal Computer (subject to change)
2. **Framework**: Built with Electron.js and TypeScript.
3. **Hot-Reload System**: Smart hot-reloading watches for public directory changes, instantly refreshing the page.
4. **TypeScript**: Fully TypeScript-compatible, rebuilding automatically on file changes.
5. **Window Creation**: Automated window setup with `bun new-win` script for streamlined development.
6. **Dynamic Window Management**: Windows can be independently closed and reopened, enhancing modularity.
7. **Tray Button**: Provides a convenient interface in the tray.
8. **Project Structure**: Organized directories and files for easy navigation and maintenance.
9. **Security Protocols**: Strict Content Security Policy (CSP) and optional development bridge.
10. **Development Bridge**: Console logs can be routed to the terminal for streamlined debugging.
11. **Automation Support**: Scripts streamline window and module creation.
12. **Public Folder Watch**: Monitors the `public` directory for changes, instantly refreshing on updates.
13. **Bundled Packages**: Support for bundled npm packages in the app.
14. **AI Research**: Contains `AI Research` directory with an experimental Burgil Personal Computer concept.
15. **Object Detection**: `ai-vision-server` plugin detects objects on the screen in real-time.
16. **Screen Drawing**: OpenCV and PyQt5 enable drawing on the screen with the `ai-vision-server`.
17. **Screenshot Capture**: `screenshot-taker` plugin saves screen areas with coordinates for detection.
18. **Moderation Layers**: Planned moderation to secure sensitive AI features before open-sourcing.
19. **Local LLM Testing**: Dedicated page to test local Large Language Models (LLM).
20. **STT/VAD/TTS Integration**: Speech-to-text (STT), Voice Activity Detection (VAD), and Text-to-speech (TTS) support.
21. **LLM Libraries**: Uses optimized libraries like `@mlc-ai/web-llm`.
22. **VAD Library**: Integrates `@ricky0123/vad-web` for voice activity detection.
23. **ONNX Runtime**: Includes `onnxruntime-web` for efficient machine learning model execution.
24. **Notification System**: Transparent UI, visually appealing, and customizable.
25. **Plugin Marketplace**: Interface for plugins, displaying metadata such as version and dependencies.
26. **Settings Page**: Customizable settings accessible in a user-friendly UI.
27. **Disclaimer Page**: Tailored disclaimer page with accessible, prominent legal sections.
28. **Automated Setup**: Scripts for automating build and testing steps.
29. **AI Vision Server**: Utilizes Python, OpenCV, and PyQt5 for detection and drawing on-screen.
30. **Image Recognition**: Capable of identifying on-screen objects, like the trash bin icon.
31. **Event Logging**: Logs key actions and errors for easier debugging.
32. **Backend Server**: Flask-based backend for handling certain plugin functionalities.
33. **Future Backend**: Plan to switch to a different backend for better scalability.
34. **Python Runtime**: Python scripts enable backend and vision server functionality.
35. **Node.js Runtime**: Core framework runtime supporting extensive JS functionality.
36. **Bun Runtime**: Bundling and package management handled by Bun.
37. **Tailwind CSS**: Simplified, responsive, and visually appealing styling.
38. **Custom CSS/JS/HTML**: Unique snippets to manage UI and plugin interfaces.
39. **Content Security**: Strong CSP settings for WebAssembly support and other content sources.
40. **STT Testing**: Section for evaluating speech-to-text functionality.
41. **Voice Highlighting**: Spoken text highlights for better accessibility.
42. **EU AI Act Compliance**: Meets requirements to limit high-risk AI use.
43. **GDPR Compliance**: Ensures privacy protection and data minimization.
44. **Privacy Notice**: Clear statement that no data is collected; stored locally.
45. **Unused Libraries**: Prunes unnecessary libraries for optimized performance.
46. **Fonts**: Font Awesome integration for icon customization.
47. **Organized File Structure**: Easily navigable with grouped directories and files.
48. **Future Plugin Integration**: Plan for plugins to allow inter-app functionality sharing.
49. **Modular Window Design**: Easily add and remove windows as per user needs.
50. **New Window Creation**: Automated script creates pre-configured windows.
51. **Easy Window Reopen**: Open previously closed windows without restarting.
52. **Error Handling**: Comprehensive error handling with alerts/logs.
53. **Console Debugging**: Console output streamed to terminal.
54. **Backend API**: API endpoints for real-time object detection.
55. **Python Integration**: Python code support, including AI model execution.
56. **Local Storage**: Stores configuration settings locally for persistence.
57. **Modular Plugins**: Plugins easily add, remove, and update functionalities.
58. **Testing Modules**: Modules in place for all critical functionalities.
59. **Screen Detection Security**: Delays open-sourcing until secure, moderated release.
60. **Open Source Plan**: Full open-source release planned post-stabilization.
61. **Notification Animations**: Visually rich animations for notifications.
62. **Plugin Dependencies**: Plugins check and list dependencies.
63. **API Documentation**: Clear API documentation for easy integration.
64. **JavaScript Utility Functions**: Helper functions in JS/TS to streamline development.
65. **HTML Utility Functions**: Helper functions for rapid UI prototyping.
66. **Tailwind Animations**: Stylish, lightweight animations via Tailwind CSS.
67. **Notification Sounds**: Optional sounds for key events.
68. **Alert Management**: Configurable alerts for important actions.
69. **Keyboard Shortcuts**: Easy navigation with shortcut keys.
70. **Accessibility Compliance**: Follows accessibility best practices.
71. **Responsiveness**: Fully responsive across screen sizes.
72. **Minimalist Design**: Simple and functional UI/UX.
73. **AI Research Files**: Reference material for AI exploration.
74. **Content Moderation**: Limitations on AI vision to prevent misuse.
75. **Image Caching**: Cached detected images for rapid access.
76. **Visual Prompts**: Visual guidelines to improve UX.
77. **Data Privacy**: Focus on secure data storage practices.
78. **Scripted Automation**: Scripts for automated build and deployment.
79. **Backend Flask**: Backend with Flask to serve API endpoints.
80. **Plugin Cache**: Plugin details stored in a JSON cache.
81. **Cross-Platform**: Cross-platform support for macOS, Windows, and Linux.
82. **Logging Framework**: Organized and detailed logs for error handling.
83. **Event Emitter**: Uses events to manage window and plugin actions.
84. **Node-PyQt5 Integration**: Coordinates Node and Python for vision capabilities.
85. **Real-Time Feedback**: Instant feedback for actions in UI.
86. **File Compression**: Efficient storage of plugin data.
87. **Command Line Options**: CLI options for easy debugging.
88. **Transparency Effects**: Enhanced UI with transparent effects.
89. **Notification Shadows**: Custom shadows for enhanced visibility.
90. **Security Focus**: Prevents malicious access via CSP and other protocols.
91. **Permissions Management**: Manages sensitive AI capabilities with permissions.
92. **Adaptive Layouts**: Optimized layouts across screens.
93. **Git Integration**: GitHub repository with stable branch setup.
94. **Plugin Management**: Handles adding, removing, and updating plugins.
95. **Window State Persistence**: Saves window size/position across sessions.
96. **Automated Tests**: In-progress plan for automated end-to-end tests.
97. **Cross-Compatibility**: Testing for compatibility with key libraries.
98. **JavaScript Polyfills**: Polyfills for browser compatibility.
99. **Styling Libraries**: Light styling frameworks to reduce load time.
100. **Pre-Release Limitations**: Clear communication about pre-release status, limited use cases, and open-source plans after stabilization.
